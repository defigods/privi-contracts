// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "./token/PRIVIPodERC1155RoyaltyToken.sol";
import "./deployable_managers/MultiCreatorNftManager.sol";
import "./interfaces/IBridgeManager.sol";

/**
 * @title   PRIVIPodERC1155RoyaltyFactory contract
 * @dev     Creates new royalty ERC1155 tokens using a factory pattern
 * @author  PRIVI
 **/
contract PRIVIPodERC1155RoyaltyFactory is AccessControl {
  bytes32 public constant MODERATOR_ROLE = keccak256("MODERATOR_ROLE");
  address public bridgeManagerAddress;
  uint256 public totalPodCreated;
  mapping(string => address) public podTokenAddresses;

  event PodCreated(string indexed uri, address podAddress);

  /**
   * @dev Grants `DEFAULT_ADMIN_ROLE` and `MODERATOR_ROLE` to the
   * account that deploys the contract.
   */
  constructor(address bridgeAddress) {
    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
    _setupRole(MODERATOR_ROLE, _msgSender());
    bridgeManagerAddress = bridgeAddress;
  }

  /**
   * @notice  Assigns `MODERATOR_ROLE` to SwapManager contract
   * @param   swapManagerAddress The SwapManager contract address
   */
  function assignRoleSwapManager(address swapManagerAddress) external {
    require(
      hasRole(MODERATOR_ROLE, _msgSender()),
      "PRIVIPodERC1155RoyaltyFactory: must have MODERATOR_ROLE to assign SwapManager address"
    );
    _setupRole(MODERATOR_ROLE, swapManagerAddress);
  }

  //TODO: getTotalTokenCreated()

  /**
   * @notice Returns the contract address of the Pod token
   * @param  uri The Pod URI
   * @return podAddress The contract address of the Pod token
   */
  function getPodAddressByUri(string calldata uri)
    external
    view
    returns (address podAddress)
  {
    podAddress = podTokenAddresses[uri];
  }

  /**
   * @notice Creates a royalty ERC1155 Pod token and registers it in the BridgeManager
   * @dev    - Pod URI must not exist
   * @param  uri The base URI
   * @param  royaltyAmount The royalty amount to be transfer to the creator
   * @param  creator The Pod token creator
   * @return podAddress The contract address of the Pod token created
   */
  function createPod(
    string calldata uri,
    uint256 royaltyAmount,
    address creator
  ) external returns (address podAddress) {
    // TODO: Check restrictions to create POD tokens
    // require(
    //   hasRole(MODERATOR_ROLE, _msgSender()),
    //   "PRIVIPodERC1155Factory: must have MODERATOR_ROLE to create pod."
    // );
    require(
      podTokenAddresses[uri] == address(0),
      "PRIVIPodERC1155RoyaltyFactory: Pod already exists"
    );

    PRIVIPodERC1155RoyaltyToken podToken =
      new PRIVIPodERC1155RoyaltyToken(
        uri,
        address(this),
        royaltyAmount,
        creator
      );
    podAddress = address(podToken);

    totalPodCreated += 1;

    podTokenAddresses[uri] = podAddress;

    IBridgeManager(bridgeManagerAddress).registerTokenERC1155(
      uri,
      uri,
      podAddress
    );

    emit PodCreated(uri, podAddress);
  }

  /**
   * @notice Creates a royalty ERC1155 Pod token generated by multiple 
   * creators and registers it in the BridgeManager
   * @dev    - Pod URI must not exist
   * @param  uri The base URI
   * @param  royaltyAmount The royalty amount to be transfer to the creator
   * @param  royaltyShares An array of royalty amounts to be shared to creators
   * @param  creators An array of Pod token creators to receive royalties
   * @return podAddress The contract address of the Pod token created
   */
  function createMultiCreatorPod(
    string calldata uri,
    uint256 royaltyAmount,
    uint256[] memory royaltyShares,
    address[] memory creators
  ) external returns (address podAddress) {
    // TODO: Check restrictions to create POD tokens
    // require(
    //   hasRole(MODERATOR_ROLE, _msgSender()),
    //   "PRIVIPodERC20RoyaltyFactory: must have MODERATOR_ROLE to create pod."
    // );
    require(
      podTokenAddresses[uri] == address(0),
      "PRIVIPodERC1155RoyaltyFactory: Pod already exists"
    );

    MultiCreatorNftManager multiCreatorManager =
      new MultiCreatorNftManager(creators, royaltyShares);

    PRIVIPodERC1155RoyaltyToken podToken =
      new PRIVIPodERC1155RoyaltyToken(
        uri,
        address(this),
        royaltyAmount,
        address(multiCreatorManager)
      );
    podAddress = address(podToken);

    totalPodCreated += 1;

    podTokenAddresses[uri] = podAddress;

    IBridgeManager(bridgeManagerAddress).registerTokenERC1155(
      uri,
      uri,
      podAddress
    );

    emit PodCreated(uri, podAddress);
  }

  /**
   * @notice Mints ERC1155 Pod tokens
   * @dev    - The caller must be MODERATOR_ROLE
   *         - destination address can't be zero
   *         - amount to be minted must be greater than zero
   * @param  uri The base URI
   * @param  account The destination account to receive minted tokens
   * @param  tokenId The Pod token identifier
   * @param  amount The amount of tokens to be minted
   * @param  data The data to be added (currently not used)
   */
  function podMint(
    string calldata uri,
    address account,
    uint256 tokenId,
    uint256 amount,
    bytes calldata data
  ) external {
    require(
      hasRole(MODERATOR_ROLE, _msgSender()),
      "PRIVIPodERC1155RoyaltyFactory: must have MODERATOR_ROLE to invest for investor"
    );
    require(
      account != address(0),
      "PRIVIPodERC1155RoyaltyFactory: Account address should not be zero"
    );
    require(amount > 0, "PRIVIPodERC1155RoyaltyFactory: amount should not be zero");

    PRIVIPodERC1155RoyaltyToken(podTokenAddresses[uri]).mint(
      account,
      tokenId,
      amount,
      data
    );
  }

  /**
   * @notice Mints a batch of ERC1155 Pod tokens
   * @dev    - The caller must be MODERATOR_ROLE
   *         - destination address can't be zero
   *         - amount to be minted must be greater than zero
   * @param  uri The base URI
   * @param  account The destination account to receive minted tokens
   * @param  tokenIds An array of Pod token identifiers
   * @param  amounts An array of token amounts to be minted
   * @param  data The data to be added (currently not used)
   */
  function podMintBatch(
    string calldata uri,
    address account,
    uint256[] memory tokenIds,
    uint256[] memory amounts,
    bytes calldata data
  ) external {
    require(
      hasRole(MODERATOR_ROLE, _msgSender()),
      "PRIVIPodERC1155RoyaltyFactory: must have MODERATOR_ROLE to invest for investor"
    );
    require(
      account != address(0),
      "PRIVIPodERC1155RoyaltyFactory: Account address should not be zero"
    );
    
    PRIVIPodERC1155RoyaltyToken(podTokenAddresses[uri]).mintBatch(
      account,
      tokenIds,
      amounts,
      data
    );
  }
}
